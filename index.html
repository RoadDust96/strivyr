<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- CSP is managed via Cloudflare Transform Rules -->
  <title>Strivyr Survey - Domain Reconnaissance Tool</title>
  <link rel="stylesheet" href="css/styles-modern.css" />
  <link rel="stylesheet" href="css/survey-modern.css" />
  <!-- Favicons -->
  <link rel="icon" type="image/png" href="images/favicon-96x96.png" sizes="96x96" />
  <link rel="icon" type="image/svg+xml" href="images/favicon.svg" />
  <link rel="shortcut icon" href="images/favicon.ico" />
  <link rel="apple-touch-icon" sizes="180x180" href="images/apple-touch-icon.png" />
  <meta name="apple-mobile-web-app-title" content="Strivyr" />
  <link rel="manifest" href="images/site.webmanifest" />
  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
</head>
<body>
  <!-- Navigation -->
  <nav>
    <div class="nav-container">
      <a href="index.html" class="logo"><img src="images/logo.png" alt="Strivyr" /></a>
      <ul class="nav-links" id="nav-links">
        <li><a href="index.html" class="active">Strivyr Survey</a></li>
        <li class="nav-dropdown">
          <a href="#" class="nav-dropdown-toggle">Projects</a>
          <div class="nav-dropdown-menu">
            <a href="tip-calculator.html">Tip Calculator</a>
            <a href="f1.html">F1 Countdown</a>
          </div>
        </li>
      </ul>
      <button class="menu-toggle" id="menu-toggle">☰</button>
    </div>
  </nav>

  <main>
    <!-- Hero Section -->
    <section class="hero hero-compact">
      <div class="hero-content">
        <h1 class="hero-title">Strivyr Survey</h1>
        <p class="hero-subtitle">Domain reconnaissance and DNS analysis tool</p>
      </div>
    </section>

    <!-- Survey Tool Section -->
    <section class="section-compact">
      <div class="survey-container">
        <!-- Domain Input -->
        <div class="domain-input-section">
          <form id="domain-form" class="domain-form">
            <input
              type="text"
              id="domain-input"
              class="domain-input"
              placeholder="example.com"
              required
              pattern="[a-zA-Z0-9.\-]+"
            />
            <button type="submit" class="submit-btn" id="submit-btn">
              Scan Domain
            </button>
          </form>
          <div id="error-message" class="error-message" style="display: none;"></div>
        </div>

        <!-- Loading State -->
        <div id="loading-state" class="loading-state" style="display: none;">
          <div class="spinner"></div>
          <p>Scanning domain...</p>
        </div>

        <!-- Results Section -->
        <div id="results-section" class="results-section">
          <div class="results-header">
            <h2 class="domain-title" id="domain-title"></h2>
            <div class="export-buttons">
              <button class="export-btn" id="export-csv">Download CSV</button>
              <button class="export-btn" id="export-json">Download JSON</button>
            </div>
          </div>

          <!-- Summary Section -->
          <div class="summary-section">
            <div class="summary-grid">
              <!-- Mini Radar Chart -->
              <div class="mini-chart-container">
                <h3 style="color: var(--text-primary); margin-bottom: var(--space-md); font-size: 1.125rem;">DNS Overview</h3>
                <canvas id="mini-radar-chart" width="250" height="250"></canvas>
              </div>

              <!-- Top Related Domains Preview -->
              <div>
                <h3 style="color: var(--text-primary); margin-bottom: var(--space-md); font-size: 1.125rem;">Top Related Domains</h3>
                <div class="related-preview" id="related-preview">
                  <div class="spinner-container">
                    <div class="spinner spinner-small"></div>
                    <span class="spinner-text">Analyzing...</span>
                  </div>
                </div>
                <a href="#" class="view-all-link" id="view-all-related">View all related domains</a>
              </div>
            </div>

            <!-- Quick Stats -->
            <div class="quick-stats">
              <div class="stat-item">
                <div class="stat-value" id="stat-total-records">--</div>
                <div class="stat-label">Total Records</div>
              </div>
              <div class="stat-item">
                <div class="stat-value" id="stat-related-count">--</div>
                <div class="stat-label">Related Domains</div>
              </div>
              <div class="stat-item">
                <div class="stat-value" id="stat-high-confidence">--</div>
                <div class="stat-label">High Confidence</div>
              </div>
            </div>
          </div>

          <!-- Tabbed Detail Sections -->
          <div class="tabbed-details">
            <!-- Tab Navigation -->
            <div class="tab-navigation" role="tablist">
              <button class="tab-btn active" role="tab" aria-selected="true" aria-controls="tab-dns" data-tab="dns">
                Full DNS Records
              </button>
              <button class="tab-btn" role="tab" aria-selected="false" aria-controls="tab-related" data-tab="related">
                All Related Domains
              </button>
            </div>

            <!-- Tab 1: DNS Records -->
            <div id="tab-dns" class="tab-content active" role="tabpanel">
              <div class="table-controls">
                <input
                  type="text"
                  id="search-box"
                  class="search-box"
                  placeholder="Search records..."
                />
                <span class="pagination-info" id="pagination-info"></span>
              </div>

              <div class="table-container">
                <table class="data-table">
                  <thead>
                    <tr>
                      <th class="sortable" data-column="type">Type</th>
                      <th class="sortable" data-column="value">Value</th>
                    </tr>
                  </thead>
                  <tbody id="table-body">
                  </tbody>
                </table>

                <div class="pagination" id="pagination"></div>
              </div>
            </div>

            <!-- Tab 2: Related Domains -->
            <div id="tab-related" class="tab-content" role="tabpanel">
              <div class="related-domains-container">
                <!-- Activity Feed -->
                <div id="activity-feed" class="activity-feed" style="display: none;">
                  <div class="activity-feed-header" onclick="toggleActivityFeed()">
                    <h3 style="color: var(--text-primary); font-size: 0.9rem; margin: 0;">Discovery Activity</h3>
                    <span id="activity-feed-toggle" class="activity-feed-toggle">▼</span>
                  </div>
                  <div id="activity-feed-content" class="activity-feed-content">
                    <!-- Activity items will be added here dynamically -->
                  </div>
                </div>

                <div id="related-domains-content">
                  <div class="spinner-container">
                    <div class="spinner"></div>
                    <span class="spinner-text">Searching for related domains...</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  </main>

  <footer>
    <div class="container">
      <p>&copy; 2025 Strivyr. Domain reconnaissance and security tools.</p>
    </div>
  </footer>

  <script>
    // State management
    let apiResponse = null;
    let tableData = [];
    let filteredData = [];
    let currentPage = 1;
    const itemsPerPage = 20;
    let sortColumn = null;
    let sortDirection = 'asc';
    let currentScanId = 0; // Track current scan to prevent race conditions

    // Security: Input sanitization utility
    const sanitizeHTML = (str) => {
      if (!str) return '';
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    };

    // Sanitize and validate domain input
    const sanitizeDomain = (domain) => {
      if (!domain) return '';
      // Remove any HTML tags, scripts, and dangerous characters
      let sanitized = sanitizeHTML(domain);
      // Allow only alphanumeric, dots, hyphens, and underscores
      sanitized = sanitized.replace(/[^a-zA-Z0-9.-]/g, '');
      // Remove leading/trailing dots and hyphens
      sanitized = sanitized.replace(/^[.-]+|[.-]+$/g, '');
      return sanitized.toLowerCase();
    };

    // Validate if a string is a valid domain format
    const isValidDomain = (domain) => {
      if (!domain || typeof domain !== 'string') return false;

      // Reject domains with invalid characters (commas, spaces, quotes, etc.)
      if (/[,\s'"(){}[\]<>|\\]/.test(domain)) return false;

      // Must contain at least one dot
      if (!domain.includes('.')) return false;

      // Must match basic domain format (alphanumeric, dots, hyphens only)
      if (!/^[a-z0-9.-]+$/i.test(domain)) return false;

      // Can't start or end with dot or hyphen
      if (/^[.-]|[.-]$/.test(domain)) return false;

      // Reject consecutive hyphens (e.g., "www--reddit.com")
      if (/--/.test(domain)) return false;

      // Reject consecutive dots (e.g., "example..com")
      if (/\.\./.test(domain)) return false;

      return true;
    };

    // Infrastructure provider blacklist - these are hosting/CDN services, not related domains
    const infrastructureProviders = new Set([
      // CDN & Hosting
      'cloudflare.com', 'cloudflaressl.com', 'cloudflare.net', 'cloudflare-dns.com',
      'akamai.com', 'akamai.net', 'akamaiedge.net', 'akamaihd.net',
      'fastly.com', 'fastly.net', 'fastlylb.net',
      'cdn77.com', 'cdn77.net',
      'cloudfront.net',
      // Cloud Providers
      'amazonaws.com', 'awsdns.com', 'awsdns.net', 'awsdns.org',
      'googleusercontent.com', 'googleapis.com', 'gstatic.com',
      'azurewebsites.net', 'azure.com', 'windows.net',
      'digitaloceanspaces.com', 'digitalocean.com',
      // SSL/Security
      'letsencrypt.org', 'digicert.com', 'sectigo.com', 'godaddy.com', 'comodo.com',
      // Analytics/Ads
      'google-analytics.com', 'googletagmanager.com', 'doubleclick.net', 'googlesyndication.com'
    ]);

    // Extract apex/root domain from any domain (e.g., "docs.google.com" -> "google.com")
    const extractApexDomain = (domain) => {
      if (!domain) return '';

      // First validate the domain format
      if (!isValidDomain(domain)) return '';

      // Remove wildcards and clean up
      let cleaned = domain.replace(/^\*\./, '').toLowerCase().trim();

      // Split into parts
      const parts = cleaned.split('.');

      // If less than 2 parts, it's invalid
      if (parts.length < 2) return '';

      // Comprehensive list of multi-part TLDs (ccSLDs and special TLDs)
      const multiPartTLDs = [
        // UK
        'co.uk', 'org.uk', 'gov.uk', 'ac.uk', 'net.uk', 'me.uk',
        // Australia
        'com.au', 'net.au', 'org.au', 'edu.au', 'gov.au',
        // New Zealand
        'co.nz', 'net.nz', 'org.nz', 'govt.nz', 'ac.nz',
        // South Africa
        'co.za', 'org.za', 'net.za', 'gov.za', 'ac.za',
        // Brazil
        'com.br', 'net.br', 'org.br', 'gov.br', 'edu.br',
        // Japan
        'co.jp', 'or.jp', 'ne.jp', 'go.jp', 'ac.jp',
        // Korea
        'co.kr', 'or.kr', 'ne.kr', 'go.kr', 'ac.kr',
        // India
        'co.in', 'net.in', 'org.in', 'gen.in', 'firm.in',
        // Asia/Pacific
        'com.sg', 'com.hk', 'com.tw', 'com.my', 'com.ph', 'com.vn', 'com.kh',
        // Americas
        'com.mx', 'com.ar', 'com.co', 'com.ve', 'com.pe', 'com.pr', 'com.bz', 'com.sv',
        // Europe
        'com.pl', 'com.tr', 'com.ua', 'com.ru',
        // Middle East/Africa
        'com.sa', 'com.eg', 'com.ng', 'com.gh', 'com.ke', 'com.ge',
        // Other
        'com.pk', 'com.bd', 'com.np'
      ];

      // Check if domain ends with multi-part TLD
      if (parts.length >= 3) {
        const lastTwoParts = parts.slice(-2).join('.');
        if (multiPartTLDs.includes(lastTwoParts)) {
          const apex = parts.slice(-3).join('.');

          // Validate: ensure the third-level part is not empty and not just a number
          const thirdLevel = parts[parts.length - 3];
          if (!thirdLevel || thirdLevel.length < 2 || /^\d+$/.test(thirdLevel)) {
            return ''; // Invalid
          }

          // Filter out infrastructure providers (CDN, hosting, cloud services)
          if (infrastructureProviders.has(apex)) {
            return ''; // Blacklisted
          }

          return apex;
        }
      }

      // Standard TLD - return last 2 parts (domain.tld)
      const apex = parts.slice(-2).join('.');

      // Validate: ensure the second-level part is not empty and not just a number
      const secondLevel = parts[parts.length - 2];
      if (!secondLevel || secondLevel.length < 2 || /^\d+$/.test(secondLevel)) {
        return ''; // Invalid
      }

      // Filter out infrastructure providers (CDN, hosting, cloud services)
      if (infrastructureProviders.has(apex)) {
        return ''; // Blacklisted
      }

      return apex;
    };

    // Common nameserver provider patterns (infrastructure that shouldn't count as relationship signal)
    const nameserverProviders = [
      'awsdns', // AWS Route 53 (e.g., ns-123.awsdns-45.com)
      'cloudflare.com', // Cloudflare DNS
      'googledomains.com', // Google Domains
      'domaincontrol.com', // GoDaddy
      'registrar-servers.com', // Namecheap
      'dnsmadeeasy.com', // DNS Made Easy
      'nsone.net', // NS1
      'ultradns.', // UltraDNS
      'dynect.net', // Dyn
      'azure-dns.', // Microsoft Azure DNS
      'digitalocean.com', // DigitalOcean DNS
      'linode.com', // Linode DNS
      'he.net', // Hurricane Electric
      'dns.', // Generic DNS services (dns.google, dns.cloudflare, etc.)
      'nameserver', // Generic nameserver patterns
    ];

    // Check if a nameserver belongs to infrastructure/hosting provider
    const isInfrastructureNameserver = (nameserver) => {
      if (!nameserver) return true; // Treat empty as infrastructure
      const ns = nameserver.toLowerCase();

      // Check against known nameserver provider patterns
      return nameserverProviders.some(provider => ns.includes(provider));
    };

    // Common mail provider patterns (infrastructure that shouldn't count as relationship signal)
    const mailProviders = [
      'google.com', 'googlemail.com', 'gmail.com', 'aspmx.l.google.com', // Google Workspace
      'outlook.com', 'hotmail.com', 'live.com', 'office365.com', 'protection.outlook.com', // Microsoft 365
      'yahoodns.net', 'yahoo.com', // Yahoo Mail
      'zoho.com', 'zohomail.com', // Zoho Mail
      'protonmail.ch', 'protonmail.com', // ProtonMail
      'mail.ru', 'yandex.ru', // Russian providers
      'sendgrid.net', 'mailgun.org', 'mailjet.com', // Transactional email services
      'amazonses.com', // Amazon SES
      'sparkpostmail.com', 'mcsv.net', 'mandrillapp.com', // Email delivery services
      'pphosted.com', 'proofpoint.com', 'mimecast.com', 'barracuda.com', // Email security
    ];

    // Check if a mail server belongs to infrastructure/email provider
    const isInfrastructureMailServer = (mailServer) => {
      if (!mailServer) return true; // Treat empty as infrastructure
      const mx = mailServer.toLowerCase();

      // Check against known mail provider patterns
      return mailProviders.some(provider => mx.includes(provider));
    };

    // DOM elements
    const domainForm = document.getElementById('domain-form');
    const domainInput = document.getElementById('domain-input');
    const submitBtn = document.getElementById('submit-btn');
    const errorMessage = document.getElementById('error-message');
    const loadingState = document.getElementById('loading-state');
    const resultsSection = document.getElementById('results-section');
    const domainTitle = document.getElementById('domain-title');
    const searchBox = document.getElementById('search-box');
    const tableBody = document.getElementById('table-body');
    const paginationInfo = document.getElementById('pagination-info');
    const pagination = document.getElementById('pagination');
    const exportCsvBtn = document.getElementById('export-csv');
    const exportJsonBtn = document.getElementById('export-json');

    // Tab management
    const tabButtons = document.querySelectorAll('.tab-btn');
    const tabContents = document.querySelectorAll('.tab-content');
    const viewAllRelatedLink = document.getElementById('view-all-related');

    // Tab switching
    tabButtons.forEach(button => {
      button.addEventListener('click', () => {
        const targetTab = button.dataset.tab;

        // Update buttons
        tabButtons.forEach(btn => {
          btn.classList.remove('active');
          btn.setAttribute('aria-selected', 'false');
        });
        button.classList.add('active');
        button.setAttribute('aria-selected', 'true');

        // Update content
        tabContents.forEach(content => {
          content.classList.remove('active');
        });
        document.getElementById(`tab-${targetTab}`).classList.add('active');
      });
    });

    // "View all" link switches to related domains tab
    if (viewAllRelatedLink) {
      viewAllRelatedLink.addEventListener('click', (e) => {
        e.preventDefault();
        const relatedTabBtn = document.querySelector('.tab-btn[data-tab="related"]');
        if (relatedTabBtn) {
          relatedTabBtn.click();

          // Scroll to the tab navigation smoothly
          const tabNavigation = document.querySelector('.tab-navigation');
          if (tabNavigation) {
            tabNavigation.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
        }
      });
    }

    // Clear all state for a fresh scan
    function clearAllState() {
      // Clear global state variables
      apiResponse = null;
      tableData = [];
      filteredData = [];
      currentPage = 1;
      sortColumn = null;
      sortDirection = 'asc';

      // Clear domain title
      domainTitle.textContent = '';

      // Clear table
      tableBody.innerHTML = '';
      paginationInfo.textContent = '';
      pagination.innerHTML = '';

      // Clear search box
      searchBox.value = '';

      // Reset quick stats to default
      document.getElementById('stat-total-records').textContent = '--';
      document.getElementById('stat-related-count').textContent = '--';
      document.getElementById('stat-high-confidence').textContent = '--';

      // Clear related domains preview
      const relatedPreview = document.getElementById('related-preview');
      relatedPreview.innerHTML = `
        <div class="spinner-container">
          <div class="spinner spinner-small"></div>
          <span class="spinner-text">Analyzing...</span>
        </div>
      `;

      // Clear full related domains content
      const relatedDomainsContent = document.getElementById('related-domains-content');
      relatedDomainsContent.innerHTML = `
        <div class="spinner-container">
          <div class="spinner"></div>
          <span class="spinner-text">Searching for related domains...</span>
        </div>
      `;

      // Destroy and clear radar chart
      if (miniRadarChart) {
        miniRadarChart.destroy();
        miniRadarChart = null;
      }

      // Reset to DNS tab
      tabButtons.forEach(btn => {
        btn.classList.remove('active');
        btn.setAttribute('aria-selected', 'false');
      });
      tabContents.forEach(content => {
        content.classList.remove('active');
      });
      const dnsTab = document.querySelector('.tab-btn[data-tab="dns"]');
      const dnsContent = document.getElementById('tab-dns');
      if (dnsTab && dnsContent) {
        dnsTab.classList.add('active');
        dnsTab.setAttribute('aria-selected', 'true');
        dnsContent.classList.add('active');
      }

      // Remove sorting classes
      document.querySelectorAll('.sortable').forEach(header => {
        header.classList.remove('sorted-asc', 'sorted-desc');
      });
    }

    // Form submission
    domainForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      const rawDomain = domainInput.value.trim();

      if (!rawDomain) return;

      // Sanitize domain input
      const domain = sanitizeDomain(rawDomain);

      if (!domain) {
        showError('Invalid domain format. Please enter a valid domain name.');
        return;
      }

      // Validate domain format with regex
      const domainRegex = /^[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?(\.[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)+$/i;
      if (!domainRegex.test(domain)) {
        showError('Invalid domain format. Please enter a valid domain name (e.g., example.com).');
        return;
      }

      // Validate domain length
      if (domain.length < 3 || domain.length > 253) {
        showError('Domain name must be between 3 and 253 characters.');
        return;
      }

      // Clear visible stats and related domains IMMEDIATELY (before anything else)
      document.getElementById('stat-total-records').textContent = '--';
      document.getElementById('stat-related-count').textContent = '--';
      document.getElementById('stat-high-confidence').textContent = '--';

      // Clear related domains preview immediately
      const relatedPreview = document.getElementById('related-preview');
      relatedPreview.innerHTML = `
        <div class="spinner-container">
          <div class="spinner spinner-small"></div>
          <span class="spinner-text">Analyzing...</span>
        </div>
      `;

      // Clear full related domains content immediately
      const relatedDomainsContent = document.getElementById('related-domains-content');
      relatedDomainsContent.innerHTML = `
        <div class="spinner-container">
          <div class="spinner"></div>
          <span class="spinner-text">Searching for related domains...</span>
        </div>
      `;

      // Hide results section and show loading
      errorMessage.style.display = 'none';
      resultsSection.classList.remove('visible');
      loadingState.style.display = 'block';
      submitBtn.disabled = true;

      // Clear remaining state after hiding results
      clearAllState();

      // Increment scan ID to track this specific scan
      currentScanId++;
      const thisScanId = currentScanId;

      try {
        console.log('Sending request to API for domain:', domain);

        const response = await fetch('https://survey.strivyr.com/api/lookup', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ domain: domain })
        });

        console.log('Response status:', response.status);

        // Check if this scan is still current
        if (thisScanId !== currentScanId) {
          console.log('Scan cancelled - newer scan in progress');
          return;
        }

        if (!response.ok) {
          const errorText = await response.text();
          console.error('API error response:', errorText);
          throw new Error(`API returned status ${response.status}: ${errorText || 'Unknown error'}`);
        }

        apiResponse = await response.json();
        console.log('API response:', apiResponse);

        // Check again before processing results
        if (thisScanId !== currentScanId) {
          console.log('Scan cancelled - newer scan in progress');
          return;
        }

        processResults(domain, apiResponse, thisScanId);

      } catch (error) {
        console.error('Error details:', error);

        // Provide more specific error messages
        let errorMsg = 'Failed to scan domain. ';

        if (error.message === 'Failed to fetch') {
          errorMsg += 'This is likely a CORS issue. The API server needs to allow requests from this domain. Please check: (1) Is the API server running? (2) Does it have CORS enabled? (3) Is the URL correct?';
        } else if (error.message.includes('NetworkError')) {
          errorMsg += 'Network error - please check your internet connection and verify the API server is running.';
        } else {
          errorMsg += error.message;
        }

        showError(errorMsg);
      } finally {
        loadingState.style.display = 'none';
        submitBtn.disabled = false;
      }
    });

    // Fetch WHOIS data via RDAP (modern WHOIS replacement)
    async function fetchWhoisData(domain) {
      try {
        // Call backend RDAP proxy
        const response = await fetch('https://survey.strivyr.com/api/rdap', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ domain: domain })
        });

        if (!response.ok) {
          console.warn(`RDAP endpoint returned ${response.status} for ${domain}`);
          return {
            registrant: {},
            registrar: '',
            nameservers: [],
            created: '',
            emails: [],
            organization: ''
          };
        }

        const result = await response.json();

        if (!result.success) {
          console.warn(`RDAP unavailable for ${domain} - ${result.error || 'service unavailable'}`);
          return result.data; // Return empty structure from backend
        }

        // Debug logging - shows parsed WHOIS data
        console.log(`RDAP success for ${domain}:`, {
          organization: result.data.organization || '(none)',
          registrar: result.data.registrar || '(none)',
          emails: result.data.emails.length ? result.data.emails : '(none)',
          nameservers: result.data.nameservers.length ? result.data.nameservers.slice(0, 2) : '(none)',
          created: result.data.created || '(none)'
        });

        return result.data;

      } catch (error) {
        console.warn(`RDAP error for ${domain}:`, error);
        return {
          registrant: {},
          registrar: '',
          nameservers: [],
          created: '',
          emails: [],
          organization: ''
        };
      }
    }

    // Fetch Certificate Transparency logs via backend proxy
    async function fetchCertificateTransparency(domain) {
      try {
        const response = await fetch('https://survey.strivyr.com/api/ct-logs', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ domain: domain })
        });

        if (!response.ok) {
          console.warn(`Certificate Transparency logs unavailable for ${domain} (${response.status}) - continuing without CT data`);
          return { certificates: [], relatedDomains: [] };
        }

        const result = await response.json();

        if (!result.success) {
          console.warn(`Certificate Transparency logs unavailable for ${domain} - ${result.error || 'service unavailable'}`);
          return { certificates: [], relatedDomains: [] };
        }

        // Debug logging - shows CT log results
        console.log(`Certificate Transparency success for ${domain}:`, {
          relatedDomains: result.data.relatedDomains?.length || 0,
          certificates: result.data.certificates?.length || 0,
          topRelated: result.data.relatedDomains?.slice(0, 5) || []
        });

        return result.data;
      } catch (error) {
        console.warn(`Certificate Transparency logs unavailable for ${domain} - continuing without CT data`);
        return { certificates: [], relatedDomains: [] };
      }
    }

    // Perform reverse IP lookup to find domains on same IPs
    async function reverseIPLookup(ipAddresses) {
      const allDomains = [];

      for (const ip of ipAddresses) {
        try {
          // Call backend reverse IP proxy
          const response = await fetch('https://survey.strivyr.com/api/reverse-ip', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ ip: ip })
          });

          if (!response.ok) {
            console.warn(`Reverse IP lookup failed for ${ip} (${response.status})`);
            continue;
          }

          const result = await response.json();

          if (!result.success) {
            console.warn(`Reverse IP lookup returned error for ${ip}: ${result.error}`);
            continue;
          }

          const domains = result.data.domains;

          // Log the raw response for debugging
          console.log(`Reverse IP lookup response for ${ip}:`, result.data);

          if (domains.length > 0) {
            console.log(`Reverse IP lookup for ${ip}: found ${domains.length} domains - ${JSON.stringify(domains)}`);
            allDomains.push(...domains);
          } else {
            console.log(`Reverse IP lookup for ${ip}: no domains found (empty array)`);
          }

          // Small delay to respect rate limits (backend handles the actual API call)
          await new Promise(resolve => setTimeout(resolve, 300));

        } catch (error) {
          console.warn(`Reverse IP lookup error for ${ip}:`, error);
        }
      }

      // Remove duplicates
      console.log(`Total domains before deduplication: ${allDomains.length} domains from ${ipAddresses.length} IPs`);
      const uniqueDomains = [...new Set(allDomains)];

      console.log(`Total reverse IP results: ${uniqueDomains.length} unique domains from ${ipAddresses.length} IPs (removed ${allDomains.length - uniqueDomains.length} duplicates)`);

      return uniqueDomains;
    }

    // Process API results
    async function processResults(domain, data, scanId) {
      // Check if this scan is still current
      if (scanId !== currentScanId) {
        console.log('processResults cancelled - newer scan in progress');
        return;
      }

      // Sanitize domain before displaying
      domainTitle.textContent = sanitizeDomain(domain);

      // Build table data
      tableData = buildTableData(data);
      filteredData = [...tableData];
      currentPage = 1;

      // Create mini radar chart for summary
      createMiniRadarChart(data);

      // Render table
      renderTable();

      // Show results
      resultsSection.classList.add('visible');

      // Fetch WHOIS and CT data in parallel for better performance
      const [whoisData, ctData] = await Promise.all([
        fetchWhoisData(domain),
        fetchCertificateTransparency(domain)
      ]);

      // Check again after async operations
      if (scanId !== currentScanId) {
        console.log('processResults cancelled after fetch - newer scan in progress');
        return;
      }

      // Perform reverse IP lookup on A records
      let reverseIPDomains = [];
      const reverseIPDiscoveredDomains = new Set(); // Track which domains were found via reverse IP

      if (data.dns?.A && Array.isArray(data.dns.A) && data.dns.A.length > 0) {
        console.log(`Starting reverse IP lookup for ${data.dns.A.length} IP addresses...`);
        reverseIPDomains = await reverseIPLookup(data.dns.A);

        // Mark all reverse IP domains
        reverseIPDomains.forEach(domain => reverseIPDiscoveredDomains.add(domain.toLowerCase()));

        // Check again after reverse IP lookup
        if (scanId !== currentScanId) {
          console.log('processResults cancelled after reverse IP - newer scan in progress');
          return;
        }
      }

      // Merge CT log domains with reverse IP domains
      const allRelatedDomains = [
        ...(ctData.relatedDomains || []),
        ...reverseIPDomains
      ];

      // Remove duplicates
      const uniqueRelatedDomains = [...new Set(allRelatedDomains)];

      // SMART PRIORITIZATION: Scan likely-related domains first
      // Tier 1 (Highest): Reverse IP discovered domains (proven infrastructure sharing)
      // Tier 2: CT log domains (potential certificate sharing)
      const reverseIPSet = new Set(reverseIPDomains.map(d => d.toLowerCase()));
      const tier1 = uniqueRelatedDomains.filter(d => reverseIPSet.has(d.toLowerCase()));
      const tier2 = uniqueRelatedDomains.filter(d => !reverseIPSet.has(d.toLowerCase()));
      const prioritizedDomains = [...tier1, ...tier2];

      console.log(`Combined discovery results (prioritized):`, {
        ctLogDomains: ctData.relatedDomains?.length || 0,
        reverseIPDomains: reverseIPDomains.length,
        totalUnique: uniqueRelatedDomains.length,
        tier1_reverseIP: tier1.length,
        tier2_ctLogs: tier2.length
      });

      // Enhance original data with WHOIS info
      const enhancedData = {
        ...data,
        whois: whoisData,
        certificates: ctData.certificates
      };

      // Debug: Log certificate data for SSL matching
      console.log(`Original domain certificate data for ${domain}:`, {
        certificateCount: enhancedData.certificates?.length || 0,
        sampleCert: enhancedData.certificates?.[0] || null
      });

      // Display related domains with enhanced confidence scoring (using prioritized order)
      displayRelatedDomains(domain, prioritizedDomains, enhancedData, scanId, reverseIPDiscoveredDomains);
    }

    // Build table data from API response
    function buildTableData(data) {
      const rows = [];

      // Helper to add rows
      const addRows = (type, items, fieldKey = null) => {
        if (!items) return;

        if (Array.isArray(items)) {
          items.forEach((item, index) => {
            if (typeof item === 'object') {
              Object.entries(item).forEach(([key, value]) => {
                rows.push({
                  type: type,
                  value: Array.isArray(value) ? value.join(', ') : String(value)
                });
              });
            } else {
              rows.push({
                type: type,
                value: String(item)
              });
            }
          });
        } else if (typeof items === 'object') {
          Object.entries(items).forEach(([key, value]) => {
            rows.push({
              type: type,
              value: Array.isArray(value) ? value.join(', ') : String(value)
            });
          });
        }
      };

      // Special handler for MX records to combine priority and exchange
      const addMxRows = (items) => {
        if (!items || !Array.isArray(items) || items.length === 0) return;

        items.forEach(item => {
          if (typeof item === 'object') {
            const hasPriority = 'priority' in item && item.priority !== null && item.priority !== undefined;
            const hasExchange = 'exchange' in item && item.exchange !== null && item.exchange !== undefined;

            // Display if either field is populated
            if (hasPriority || hasExchange) {
              const priorityValue = hasPriority ? item.priority : '(Priority)';
              const exchangeValue = hasExchange ? item.exchange : '(Exchange)';
              rows.push({
                type: 'MX Records',
                value: `${priorityValue}:${exchangeValue}`
              });
            }
          }
        });
      };

      // Process each data type - only show CNAME, A, AAAA, MX, and NS
      if (data.dns) {
        addRows('CNAME Records', data.dns.CNAME);
        addRows('A Records', data.dns.A);
        addRows('AAAA Records', data.dns.AAAA);
        addMxRows(data.dns.MX); // Use special handler for MX records
        addRows('NS Records', data.dns.NS);
      }

      return rows;
    }

    // Create mini radar chart (250px version for summary)
    let miniRadarChart = null;

    function createMiniRadarChart(data) {
      const chartData = {
        'CNAME': getCount(data.dns?.CNAME),
        'A': getCount(data.dns?.A),
        'AAAA': getCount(data.dns?.AAAA),
        'MX': getCount(data.dns?.MX),
        'NS': getCount(data.dns?.NS)
      };

      const ctx = document.getElementById('mini-radar-chart');

      if (!ctx) return;

      // Destroy existing chart
      if (miniRadarChart) {
        miniRadarChart.destroy();
      }

      miniRadarChart = new Chart(ctx, {
        type: 'radar',
        data: {
          labels: Object.keys(chartData),
          datasets: [{
            label: 'Record Count',
            data: Object.values(chartData),
            backgroundColor: 'rgba(0, 255, 249, 0.15)',
            borderColor: 'var(--neon-cyan)',
            borderWidth: 2,
            pointBackgroundColor: 'var(--neon-cyan)',
            pointBorderColor: '#fff',
            pointHoverBackgroundColor: '#fff',
            pointHoverBorderColor: 'var(--neon-cyan)',
            pointRadius: 4,
            pointHoverRadius: 6
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          scales: {
            r: {
              beginAtZero: true,
              ticks: {
                stepSize: 1,  // Only show whole numbers (no 0.5, 1.5, etc.)
                color: '#cbd5e1',  // Light gray for numbers
                font: { size: 10 },
                backdropColor: 'transparent'
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.1)'
              },
              pointLabels: {
                color: '#ffffff',  // White for labels (CNAME, A, MX, etc.)
                font: { size: 11, weight: '600' }
              }
            }
          },
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              backgroundColor: 'rgba(15, 23, 42, 0.95)',
              titleColor: '#ffffff',
              bodyColor: '#cbd5e1',
              borderColor: '#00fff9',
              borderWidth: 1,
              padding: 12,
              cornerRadius: 8
            }
          }
        }
      });
    }

    // Get count helper
    function getCount(item) {
      if (!item) return 0;
      if (Array.isArray(item)) return item.length;
      if (typeof item === 'object') return Object.keys(item).length;
      return 1;
    }

    // Search functionality
    searchBox.addEventListener('input', (e) => {
      // Sanitize search input
      const rawSearch = e.target.value.toLowerCase();
      const searchTerm = sanitizeHTML(rawSearch);

      if (!searchTerm) {
        filteredData = [...tableData];
      } else {
        filteredData = tableData.filter(row =>
          row.type.toLowerCase().includes(searchTerm) ||
          row.value.toLowerCase().includes(searchTerm)
        );
      }

      currentPage = 1;
      renderTable();
    });

    // Sorting functionality
    document.querySelectorAll('.sortable').forEach(th => {
      th.addEventListener('click', () => {
        const column = th.dataset.column;

        if (sortColumn === column) {
          sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
        } else {
          sortColumn = column;
          sortDirection = 'asc';
        }

        // Update UI
        document.querySelectorAll('.sortable').forEach(header => {
          header.classList.remove('sorted-asc', 'sorted-desc');
        });
        th.classList.add(sortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');

        // Sort data
        filteredData.sort((a, b) => {
          const aVal = a[column].toLowerCase();
          const bVal = b[column].toLowerCase();

          if (sortDirection === 'asc') {
            return aVal > bVal ? 1 : -1;
          } else {
            return aVal < bVal ? 1 : -1;
          }
        });

        renderTable();
      });
    });

    // Render table
    function renderTable() {
      const start = (currentPage - 1) * itemsPerPage;
      const end = start + itemsPerPage;
      const pageData = filteredData.slice(start, end);

      // Render rows - sanitize all data before rendering
      tableBody.innerHTML = pageData.map(row => `
        <tr>
          <td><span class="type-badge">${sanitizeHTML(row.type)}</span></td>
          <td>${sanitizeHTML(row.value)}</td>
        </tr>
      `).join('');

      // Update pagination info
      paginationInfo.textContent = `Showing ${start + 1}-${Math.min(end, filteredData.length)} of ${filteredData.length} results`;

      // Render pagination
      renderPagination();
    }

    // Render pagination
    function renderPagination() {
      const totalPages = Math.ceil(filteredData.length / itemsPerPage);

      let html = `
        <button class="page-btn" ${currentPage === 1 ? 'disabled' : ''} onclick="changePage(${currentPage - 1})">Previous</button>
      `;

      // Show page numbers
      for (let i = 1; i <= totalPages; i++) {
        if (
          i === 1 ||
          i === totalPages ||
          (i >= currentPage - 2 && i <= currentPage + 2)
        ) {
          html += `
            <button class="page-btn ${i === currentPage ? 'active' : ''}" onclick="changePage(${i})">${i}</button>
          `;
        } else if (i === currentPage - 3 || i === currentPage + 3) {
          html += `<span style="padding: 0.5rem;">...</span>`;
        }
      }

      html += `
        <button class="page-btn" ${currentPage === totalPages ? 'disabled' : ''} onclick="changePage(${currentPage + 1})">Next</button>
      `;

      pagination.innerHTML = html;
    }

    // Change page
    function changePage(page) {
      const totalPages = Math.ceil(filteredData.length / itemsPerPage);
      if (page < 1 || page > totalPages) return;
      currentPage = page;
      renderTable();
    }

    // Export CSV
    exportCsvBtn.addEventListener('click', () => {
      const csvContent = [
        ['Type', 'Value'],
        ...tableData.map(row => [row.type, row.value])
      ].map(row => row.map(cell => `"${cell}"`).join(',')).join('\n');

      downloadFile(csvContent, `${domainTitle.textContent}_survey.csv`, 'text/csv');
    });

    // Export JSON
    exportJsonBtn.addEventListener('click', () => {
      const jsonContent = JSON.stringify(apiResponse, null, 2);
      downloadFile(jsonContent, `${domainTitle.textContent}_survey.json`, 'application/json');
    });

    // Download file helper
    function downloadFile(content, filename, mimeType) {
      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // Helper function to find array overlap
    function findArrayOverlap(arr1, arr2) {
      if (!arr1 || !arr2 || !Array.isArray(arr1) || !Array.isArray(arr2)) return [];
      return arr1.filter(item => arr2.includes(item));
    }

    // Known hosting provider and CDN patterns that issue multi-tenant certificates
    const HOSTING_PROVIDER_PATTERNS = [
      /.*secureserver\.net$/i,           // GoDaddy
      /.*cloudflaressl\.com$/i,          // Cloudflare
      /sni\d*\.cloudflaressl\.com$/i,    // Cloudflare SNI
      /.*\.cloudfront\.net$/i,           // AWS CloudFront
      /.*\.amazonaws\.com$/i,            // AWS
      /.*\.azurewebsites\.net$/i,        // Azure
      /.*\.herokuapp\.com$/i,            // Heroku
      /.*\.netlify\.app$/i,              // Netlify
      /.*\.vercel\.app$/i,               // Vercel
      /.*\.github\.io$/i,                // GitHub Pages
      /.*\.wordpress\.com$/i,            // WordPress hosting
      /.*\.wixdns\.net$/i,               // Wix
      /.*\.shopifycloud\.com$/i,         // Shopify
      /.*\.squarespace\.com$/i,          // Squarespace
      /.*\.webfaction\.com$/i,           // WebFaction
      /.*\.hostgator\.com$/i,            // HostGator
      /.*\.bluehost\.com$/i              // BlueHost
    ];

    // Helper function to check if a CN is from a known hosting provider
    function isHostingProviderCert(commonName) {
      if (!commonName) return false;
      const cleanCN = commonName.replace('*.', '').toLowerCase();
      return HOSTING_PROVIDER_PATTERNS.some(pattern => pattern.test(cleanCN));
    }

    // Helper function to check if CN is relevant to the domains being compared
    function isCNRelevantToDomains(commonName, apex1, apex2) {
      if (!commonName) return false;
      const cleanCN = commonName.replace('*.', '').toLowerCase();
      const cnApex = extractApexDomain(cleanCN);

      // CN should match one of the apex domains we're comparing
      return cnApex === apex1 || cnApex === apex2;
    }

    // Helper function to check if domains share certificates
    function domainsShareCertificate(domain1, domain2, certificates) {
      if (!certificates || !Array.isArray(certificates)) {
        console.log(`SSL cert check: No certificates available for ${domain1} vs ${domain2}`);
        return false;
      }

      // Extract apex domains for comparison (www.coca-cola.com -> coca-cola.com)
      const apex1 = extractApexDomain(domain1);
      const apex2 = extractApexDomain(domain2);

      const result = certificates.some(cert => {
        // FILTER 1: Check if CN is from a known hosting provider (immediate reject)
        if (isHostingProviderCert(cert.common_name)) {
          console.log(`SSL cert REJECTED: Hosting provider certificate detected (CN: ${cert.common_name})`);
          return false;
        }

        // A certificate covers both CN (common_name) and SAN (name_value) domains
        const allDomains = [];

        // Add common_name (CN) if present
        if (cert.common_name) {
          allDomains.push(cert.common_name);
        }

        // Add all SAN domains from name_value
        if (cert.name_value) {
          allDomains.push(...cert.name_value.split('\n'));
        }

        // FILTER 2: Certificate size threshold - reject certs with too many domains
        // Legitimate company certs typically have 2-30 domains, hosting providers have 50-500+
        const MAX_CERT_DOMAINS = 30;
        if (allDomains.length > MAX_CERT_DOMAINS) {
          console.log(`SSL cert REJECTED: Too many domains in certificate (${allDomains.length} domains, max ${MAX_CERT_DOMAINS}) - likely shared hosting`);
          return false;
        }

        // Remove wildcards, convert to lowercase, extract apex domains
        const certApexDomains = allDomains
          .map(d => d.replace('*.', '').toLowerCase())
          .map(d => extractApexDomain(d))
          .filter(d => d); // Remove empty results

        // Check if both domains appear in the certificate
        const hasMatch = certApexDomains.includes(apex1) && certApexDomains.includes(apex2);

        if (!hasMatch) {
          return false;
        }

        // FILTER 3: CN Relevance Check - CN should be related to at least one domain
        if (!isCNRelevantToDomains(cert.common_name, apex1, apex2)) {
          console.log(`SSL cert REJECTED: CN not relevant to domains (CN: ${cert.common_name}, domains: ${apex1}, ${apex2})`);
          return false;
        }

        // All filters passed - this is a legitimate shared certificate
        console.log(`SSL cert MATCH found: ${domain1} (apex: ${apex1}) and ${domain2} (apex: ${apex2}) share certificate (CN: ${cert.common_name}, ${allDomains.length} total domains)`);

        return true;
      });

      if (!result) {
        console.log(`SSL cert check: No shared certificate found for ${domain1} (apex: ${apex1}) vs ${domain2} (apex: ${apex2}) - checked ${certificates.length} certs`);
      }

      return result;
    }

    // Enhanced confidence scoring with WHOIS, DNS, and certificate data
    async function calculateConfidence(originalDomain, relatedDomain, originalData, relatedData, reverseIPDiscoveredDomains = new Set()) {
      let points = 0;
      const signals = [];

      // Category 1: WHOIS Registration Match (40% weight = up to 8 points)
      if (originalData.whois && relatedData.whois) {
        // Same registrant email (5 points - strongest signal)
        if (originalData.whois.emails && relatedData.whois.emails) {
          const sharedEmails = findArrayOverlap(originalData.whois.emails, relatedData.whois.emails);
          if (sharedEmails.length > 0) {
            points += 5;
            signals.push({ type: 'whois_email', value: 'Same registrant email', points: 5 });
          }
        }

        // Same organization (4 points)
        if (originalData.whois.organization && relatedData.whois.organization &&
            originalData.whois.organization === relatedData.whois.organization) {
          points += 4;
          signals.push({ type: 'whois_org', value: `Same organization: ${originalData.whois.organization}`, points: 4 });
        }

        // Same registrar (1 point)
        if (originalData.whois.registrar && relatedData.whois.registrar &&
            originalData.whois.registrar === relatedData.whois.registrar) {
          points += 1;
          signals.push({ type: 'registrar', value: 'Same registrar', points: 1 });
        }
      }

      // Category 2: SSL Certificate Analysis
      // Note: Just appearing in CT logs means nothing - we only score actual certificate sharing
      // Lowered from +5 to +2 to prevent vendor relationship false positives (requires additional signals to pass threshold)

      // Shared certificate (2 points - medium signal, prevents cert-only matches)
      if (originalData.certificates && domainsShareCertificate(originalDomain, relatedDomain, originalData.certificates)) {
        points += 2;
        signals.push({ type: 'shared_cert', value: 'Shared SSL certificate', points: 2 });
      }

      // Category 3: Infrastructure Overlap (15% weight = up to 3 points)
      if (originalData.dns && relatedData.dns) {
        // Shared nameservers (2 points) - but only if they're NOT infrastructure providers
        const nsOverlap = findArrayOverlap(originalData.dns.NS, relatedData.dns.NS);

        // Filter out infrastructure nameservers (GoDaddy, AWS, Cloudflare, etc.)
        const customNameservers = nsOverlap.filter(ns => !isInfrastructureNameserver(ns));

        if (customNameservers.length > 0) {
          points += 2;
          signals.push({ type: 'shared_ns', value: `${customNameservers.length} shared nameservers`, points: 2 });
        }

        // Shared IP addresses (2 points)
        // This catches both exact IP matches AND domains found via reverse IP lookup
        const ipOverlap = findArrayOverlap(originalData.dns.A, relatedData.dns.A);
        if (ipOverlap.length > 0) {
          points += 2;
          signals.push({ type: 'shared_ip', value: `${ipOverlap.length} shared IPs`, points: 2 });
        } else if (reverseIPDiscoveredDomains.has(relatedDomain.toLowerCase())) {
          // Domain was discovered via reverse IP but IPs don't currently match
          // This happens when domains have migrated IPs, use CDNs, or reverse IP data is stale
          points += 2;
          signals.push({ type: 'reverse_ip_historical', value: 'Historical shared IP (reverse IP discovery)', points: 2 });
        }

        // Shared mail servers (2 points) - but only if they're NOT infrastructure providers
        // Check if MX is an array before calling .map()
        if (Array.isArray(originalData.dns.MX) && Array.isArray(relatedData.dns.MX)) {
          const mxOverlap = findArrayOverlap(
            originalData.dns.MX.map(mx => mx.exchange || mx),
            relatedData.dns.MX.map(mx => mx.exchange || mx)
          );

          // Filter out infrastructure mail providers (Google Workspace, Microsoft 365, etc.)
          const customMailServers = mxOverlap.filter(mx => !isInfrastructureMailServer(mx));

          if (customMailServers.length > 0) {
            points += 2;
            signals.push({ type: 'shared_mx', value: `${customMailServers.length} shared mail servers`, points: 2 });
          }
        }
      }

      // Category 4: Name Similarity (10% weight = up to 2 points)
      // Only apply name matching for domains with 12+ characters
      if (originalDomain.length >= 12 || relatedDomain.length >= 12) {
        const similarity = calculateStringSimilarity(originalDomain, relatedDomain);
        if (similarity > 0.9) {
          // Very high similarity (>90%) = 2 points
          points += 2;
          signals.push({ type: 'name_similarity', value: `${Math.round(similarity * 100)}% name match`, points: 2 });
        } else if (similarity > 0.7) {
          // Moderate similarity (70-90%) = 1 point
          points += 1;
          signals.push({ type: 'name_similarity', value: `${Math.round(similarity * 100)}% name match`, points: 1 });
        }
      }

      // Note: Same TLD removed - too weak a signal (most domains use .com)

      // Confidence is the direct sum of all signal points (no scaling)
      // Example: "4 shared IPs (+3)" + "2 shared mail servers (+2)" = +5 confidence
      const confidence = points;

      return { score: points, confidence, signals };
    }

    // String similarity calculation (Levenshtein distance)
    function calculateStringSimilarity(str1, str2) {
      const track = Array(str2.length + 1).fill(null).map(() =>
        Array(str1.length + 1).fill(null));

      for (let i = 0; i <= str1.length; i++) track[0][i] = i;
      for (let j = 0; j <= str2.length; j++) track[j][0] = j;

      for (let j = 1; j <= str2.length; j++) {
        for (let i = 1; i <= str1.length; i++) {
          const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;
          track[j][i] = Math.min(
            track[j][i - 1] + 1,
            track[j - 1][i] + 1,
            track[j - 1][i - 1] + indicator
          );
        }
      }

      const distance = track[str2.length][str1.length];
      return 1 - (distance / Math.max(str1.length, str2.length));
    }

    // Activity Feed Functions
    function toggleActivityFeed() {
      const feed = document.getElementById('activity-feed');
      feed.classList.toggle('collapsed');
    }

    function showActivityFeed() {
      const feed = document.getElementById('activity-feed');
      feed.style.display = 'block';
      // Clear previous activity
      document.getElementById('activity-feed-content').innerHTML = '';
    }

    function hideActivityFeed() {
      const feed = document.getElementById('activity-feed');
      feed.style.display = 'none';
    }

    function addActivityItem(domain, status, data = {}) {
      const content = document.getElementById('activity-feed-content');
      const item = document.createElement('div');
      item.className = `activity-item ${status}`;
      item.id = `activity-${domain.replace(/\./g, '-')}`;

      let html = `<div class="activity-item-domain">`;

      if (status === 'success') {
        html += `✓ ${sanitizeHTML(domain)}`;
        if (data.points) {
          html += ` <span style="color: var(--neon-cyan); font-weight: 700;">(+${data.points} points)</span>`;
        }
      } else if (status === 'scanning') {
        html += `⏳ ${sanitizeHTML(domain)} - Analyzing signals...`;
      } else if (status === 'skipped') {
        html += `⊘ ${sanitizeHTML(domain)} - ${data.reason || 'Below threshold'}`;
      }

      html += `</div>`;

      // Add signals if present
      if (data.signals && data.signals.length > 0) {
        html += `<div class="activity-item-signals">`;
        data.signals.forEach(signal => {
          html += `<span class="activity-signal">${sanitizeHTML(signal.value)} (+${signal.points})</span>`;
        });
        html += `</div>`;
      }

      item.innerHTML = html;
      content.appendChild(item);

      // Auto-scroll to bottom
      content.scrollTop = content.scrollHeight;

      return item;
    }

    function updateActivityItem(domain, status, data = {}) {
      const itemId = `activity-${domain.replace(/\./g, '-')}`;
      const existingItem = document.getElementById(itemId);

      if (existingItem) {
        existingItem.remove();
      }

      addActivityItem(domain, status, data);
    }

    // Display related domains with confidence scores
    async function displayRelatedDomains(originalDomain, relatedDomains, originalData, scanId, reverseIPDiscoveredDomains = new Set()) {
      const container = document.getElementById('related-domains-content');

      // Check if this scan is still current
      if (scanId !== currentScanId) {
        console.log('displayRelatedDomains cancelled - newer scan in progress');
        return;
      }

      if (!relatedDomains || relatedDomains.length === 0) {
        // Check again before updating UI
        if (scanId !== currentScanId) return;

        container.innerHTML = '<p style="color: var(--text-secondary);">No related domains found.</p>';
        // Update preview and stats with empty data
        displayRelatedPreview([]);
        updateQuickStats(tableData, []);
        return;
      }

      // Filter to only apex domains (remove subdomains)
      const originalApex = extractApexDomain(originalDomain);

      // Extract apex domains from all related domains
      const apexDomains = relatedDomains
        .map(domain => extractApexDomain(domain))
        .filter(apex => {
          // Filter out the original domain
          if (apex === originalApex) return false;
          // Filter out empty/invalid
          if (!apex || apex.length < 3) return false;
          return true;
        });

      // Remove duplicates
      const uniqueApexDomains = [...new Set(apexDomains)];

      // Check if scan is still current
      if (scanId !== currentScanId) return;

      if (uniqueApexDomains.length === 0) {
        // Check again before updating UI
        if (scanId !== currentScanId) return;

        container.innerHTML = '<p style="color: var(--text-secondary);">No related apex domains found. Only subdomains were discovered.</p>';
        displayRelatedPreview([]);
        updateQuickStats(tableData, []);
        return;
      }

      // Use all unique apex domains (sequential processing with delays prevents rate limiting)
      const limitedDomains = uniqueApexDomains;

      // Check if scan is still current before showing loading
      if (scanId !== currentScanId) return;

      // Show activity feed
      showActivityFeed();

      // Show loading state with spinner
      container.innerHTML = `
        <div class="spinner-container">
          <div class="spinner"></div>
          <span class="spinner-text">Analyzing ${limitedDomains.length} related domains...</span>
        </div>
      `;

      // Helper function to delay between requests
      const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

      // Helper function to retry on rate limit with exponential backoff
      const fetchWithRetry = async (url, options, maxRetries = 3) => {
        for (let attempt = 0; attempt < maxRetries; attempt++) {
          try {
            const response = await fetch(url, options);

            // If rate limited (429), wait and retry with exponential backoff
            if (response.status === 429) {
              const waitTime = Math.min(1000 * Math.pow(2, attempt), 8000); // Max 8 seconds
              console.warn(`Rate limited (429) - retrying in ${waitTime}ms (attempt ${attempt + 1}/${maxRetries})`);
              await delay(waitTime);
              continue;
            }

            return response;
          } catch (error) {
            if (attempt === maxRetries - 1) throw error;
            await delay(1000 * Math.pow(2, attempt));
          }
        }
        throw new Error('Max retries exceeded');
      };

      // Track valid domains for incremental display
      const validDomains = [];
      let analyzedCount = 0;

      // Helper function to render a single domain card
      const renderDomainCard = (item) => `
        <div class="related-domain-card" style="background: var(--bg-elevated); border: 1px solid var(--border-default); border-radius: 8px; padding: 1.5rem; margin-bottom: 1rem;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.75rem;">
            <span style="color: var(--text-primary); font-size: 1.125rem; font-weight: 600;">${sanitizeHTML(item.domain)}</span>
            <span style="background: var(--accent-primary); color: #ffffff; padding: 0.5rem 1rem; border-radius: 8px; font-size: 1.25rem; font-weight: 700;">+${item.confidence}</span>
          </div>
          <div style="display: flex; flex-wrap: wrap; gap: 0.5rem; margin-top: 1rem;">
            ${item.signals.map(signal => `
              <span style="background: var(--bg-secondary); border: 1px solid var(--border-default); color: var(--text-secondary); padding: 0.25rem 0.75rem; border-radius: 12px; font-size: 0.75rem; font-weight: 500;">
                ${sanitizeHTML(signal.value)} (+${signal.points})
              </span>
            `).join('')}
          </div>
        </div>
      `;

      // Helper function to update the display with current valid domains
      const updateDisplay = () => {
        if (scanId !== currentScanId) return;

        if (validDomains.length === 0) {
          // Show "analyzing" message while we're still scanning
          if (analyzedCount < limitedDomains.length) {
            container.innerHTML = `
              <div class="spinner-container">
                <div class="spinner"></div>
                <span class="spinner-text">Analyzing related domains... (${analyzedCount}/${limitedDomains.length})</span>
              </div>
            `;
          } else {
            // All scans complete, no valid domains found
            container.innerHTML = '<p style="color: var(--text-secondary);">No meaningfully related domains found.</p>';
          }
        } else {
          // Render all valid domains sorted by confidence
          const sortedDomains = [...validDomains].sort((a, b) => b.score - a.score);
          const cardsHtml = sortedDomains.map(renderDomainCard).join('');

          // Debug: Log when we're rendering domains
          console.log(`📊 Displaying ${validDomains.length} related domains (${analyzedCount}/${limitedDomains.length} analyzed)`);

          // Show results with progress indicator AT THE TOP if still scanning
          if (analyzedCount < limitedDomains.length) {
            container.innerHTML = `
              <div class="spinner-container" style="margin-bottom: 1.5rem; padding: 1rem; background: var(--bg-elevated); border: 1px solid var(--border-default); border-radius: 8px;">
                <div class="spinner"></div>
                <span class="spinner-text">Finding more related domains... (${analyzedCount}/${limitedDomains.length})</span>
              </div>
              ${cardsHtml}
            `;
          } else {
            // Scanning complete - show final count at top
            container.innerHTML = `
              <div style="margin-bottom: 1.5rem; padding: 1rem; background: var(--bg-elevated); border: 1px solid var(--accent-primary); border-radius: 8px; color: var(--accent-primary); text-align: center; font-weight: 600;">
                ✓ Scan complete - Found ${validDomains.length} related ${validDomains.length === 1 ? 'domain' : 'domains'}
              </div>
              ${cardsHtml}
            `;
          }
        }

        // Update preview and stats with current valid domains
        displayRelatedPreview(validDomains.sort((a, b) => b.score - a.score));
        updateQuickStats(tableData, validDomains);
      };

      // INCREMENTAL SCANNING: Display each qualifying domain immediately
      for (let i = 0; i < limitedDomains.length; i++) {
        // Check if scan is still current before each iteration
        if (scanId !== currentScanId) {
          console.log('displayRelatedDomains cancelled during fetch loop - newer scan in progress');
          return;
        }

        const domain = limitedDomains[i];

        // Add scanning status to activity feed
        addActivityItem(domain, 'scanning');

        try {
          // Fetch DNS data with retry logic
          const dnsResponse = await fetchWithRetry('https://survey.strivyr.com/api/lookup', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ domain: domain })
          });
          const dnsData = await dnsResponse.json();

          // Check after async operation
          if (scanId !== currentScanId) return;

          // Small delay between requests to avoid rate limiting
          await delay(300);

          // Check after delay
          if (scanId !== currentScanId) return;

          // Fetch WHOIS data
          const whoisData = await fetchWhoisData(domain);

          // Check after async operation
          if (scanId !== currentScanId) return;

          const relatedData = {
            domain: domain,
            dns: dnsData.dns || {},
            whois: whoisData
          };

          // Calculate confidence immediately
          const confidence = await calculateConfidence(
            originalDomain,
            relatedData.domain,
            originalData,
            relatedData,
            reverseIPDiscoveredDomains
          );

          // Check after confidence calculation
          if (scanId !== currentScanId) return;

          // If domain qualifies (confidence >= 3), add it to the list
          if (confidence.confidence >= 3 && confidence.signals.length > 0) {
            validDomains.push({
              domain: relatedData.domain,
              confidence: confidence.confidence,
              score: confidence.score,
              signals: confidence.signals
            });

            // Update activity feed with success
            updateActivityItem(domain, 'success', {
              points: confidence.confidence,
              signals: confidence.signals
            });

            console.log(`✓ Found related domain: ${domain} (confidence: +${confidence.confidence})`);
          } else {
            // Update activity feed with skipped status
            updateActivityItem(domain, 'skipped', {
              reason: confidence.signals.length === 0 ? 'No signals found' : `Below threshold (${confidence.confidence} points)`
            });
          }

          // Small delay before next domain
          await delay(300);

        } catch (error) {
          console.error(`Error fetching data for ${domain}:`, error);
          // Update activity feed with error
          updateActivityItem(domain, 'skipped', {
            reason: 'Error fetching data'
          });
        }

        // Increment analyzed count BEFORE updating display
        analyzedCount++;

        // Update display after each domain is processed (whether it qualified or not)
        // This ensures the user sees incremental progress
        if (scanId !== currentScanId) return;
        updateDisplay();
      }

      // Final update after all scanning complete
      if (scanId !== currentScanId) {
        console.log('displayRelatedDomains cancelled after scanning - newer scan in progress');
        return;
      }

      console.log(`Scanning complete for ${originalDomain}:`, {
        totalAnalyzed: analyzedCount,
        validDomainsFound: validDomains.length,
        breakdown: validDomains.map(d => ({
          domain: d.domain,
          confidence: d.confidence,
          signals: d.signals.map(s => `${s.type}:+${s.points}`)
        }))
      });

      // Final display update
      updateDisplay();
    }

    // Display top 3 related domains in summary preview
    function displayRelatedPreview(domainsWithConfidence) {
      const previewContainer = document.getElementById('related-preview');

      if (!domainsWithConfidence || domainsWithConfidence.length === 0) {
        previewContainer.innerHTML = '<p style="color: var(--text-secondary); font-size: 0.875rem;">No related domains found</p>';
        return;
      }

      // Get top 3
      const top3 = domainsWithConfidence.slice(0, 3);

      const html = top3.map(item => `
        <div class="related-preview-card">
          <span class="preview-domain">${sanitizeHTML(item.domain)}</span>
          <span class="preview-confidence">+${item.confidence}</span>
        </div>
      `).join('');

      previewContainer.innerHTML = html;
    }

    // Update quick stats in summary section
    function updateQuickStats(tableData, relatedDomains) {
      const totalRecords = tableData.length;
      const relatedCount = relatedDomains.length;
      // High confidence = 5+ points (multiple meaningful signals or one very strong signal)
      const highConfidence = relatedDomains.filter(d => d.confidence >= 5).length;

      document.getElementById('stat-total-records').textContent = totalRecords;
      document.getElementById('stat-related-count').textContent = relatedCount;
      document.getElementById('stat-high-confidence').textContent = highConfidence;
    }

    // Show error
    function showError(message) {
      errorMessage.textContent = message;
      errorMessage.style.display = 'block';
    }

    // Make changePage global for onclick handlers
    window.changePage = changePage;
  </script>
  <script src="js/mobile-menu.js"></script>
</body>
</html>
